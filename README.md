# XML & JSON парсер из XML, описывающего UML-диаграмму  (Yadro тестовое задание)

## Обзор проекта

Этот репозиторий предоставляет программу, получающую конфигурацию XML и файла метаданных JSON из входного XML-файла, однозначно описывающего UML-диаграмму.

Он поддерживает:

- **Config XML** (`out/config.xml`): Представляет собой пример внутренней конфигурации базовой станции на основе модели класса.
- **Meta JSON** (`out/meta.json`): Содержит метаданные о классах, их атрибутах и взаимосвязях, используемые интерфейсной частью для отображения дерева объектов в пользовательском интерфейсе.

## Структура проекта

``` 
├── input/                  # Входные данные
│   └── test_input.xml      # Описание информационной модели
├── out/                    # Выходные данные
│   ├── config.xml
│   └── meta.json
├── source/                 # Исходный код
│   ├── model_builder.py    # Отвечает за разбор XML-модели и построение структуры классов.
│   ├── xml_maker.py        # Создает файл config.xml
│   └── json_maker.py       # Создает файл meta.json
└── main.py                 # Точка входа: управляет синтаксическим анализом и генерацией файлов.
```

## Описание исходных файлов

### `source/model_builder.py`

Этот модуль отвечает за разбор входного XML-файла и построение объектной модели, отражающей структуру UML-классов.

- **Класс `UMLClass`** — структура, описывающая класс: имя, документация, корневой ли он, список атрибутов, дочерние классы и мультиплицированность.
- **Класс `ModelBuilder`** — парсит XML-файл, находит классы и связи между ними (агрегации), строит словарь объектов `UMLClass`.
  - Метод `build_model()` — основной метод, возвращает словарь классов по их именам.

Особенности:
- Поддержка агрегаций через элемент `Aggregation`.
- Учитывается атрибут `isRoot` для определения корневого класса.
- Сохраняется порядок определения классов.

### `source/xml_maker.py`

Отвечает за генерацию выходного конфигурационного XML-файла (`config.xml`) на основе построенной модели.

- **Функция `build_xml_node()`** — рекурсивно создает XML-узлы для каждого класса, включая его атрибуты и дочерние элементы.
- **Функция `generate_config_xml()`** — определяет корневой класс, вызывает рекурсивную генерацию и сохраняет результат в виде красиво отформатированного XML.

Особенности:
- Используется модуль `xml.etree.ElementTree` и `xml.dom.minidom` для генерации и форматирования.
- Атрибуты классов сохраняются как текстовые узлы, а дочерние классы — как вложенные теги.

### `source/json_maker.py`

Создает мета-информацию о классах в формате JSON (`meta.json`) для использования на фронтенде.

- **Функция `parse_multiplicity()`** — разбирает строку мультиплицированности (например, `1..n`) на минимальное и максимальное значения.
- **Функция `generate_meta_json()`** — создает список словарей с описанием классов: имя, документация, параметры (атрибуты и дочерние классы), а также границы мультиплицированности.

Особенности:
- Формат результата соответствует требованиям UI (например, дерево объектов).
- Поля `min` и `max` добавляются, только если задана мультиплицированность.

### `main.py`

Главный скрипт, который связывает все модули вместе:

- Загружает модель с помощью `ModelBuilder`.
- Генерирует `config.xml` и `meta.json` в директорию `out/`.

## Преимущества проекта

- **Модульная архитектура**  
  Каждый этап обработки (парсинг, генерация XML, генерация JSON) выделен в отдельный модуль, что облегчает сопровождение и расширение кода.

- **Читаемые выходные файлы**  
  Сохраняется форматирование и вид выходных файлов .json и .xml

- **Гибкость модели**  
  Можно добавлять новые классы и атрибуты во входной XML без изменения кода генерации.

## Недостатки

- **Ожидается один корневой класс**  
  Алгоритм предполагает, что в модели задан только один `isRoot=true`. Несколько корневых узлов пока не поддерживаются.

- **Отсутствие валидации входного XML**  
  Нет проверки структуры и обязательных атрибутов. Ожидается корректный входной XML-файл.


## Возможные улучшения

- Добавить валидацию входного XML
- Реализовать поддержку нескольких корневых классов
- Добавить юнит-тесты и CI

## Использование

### Предварительные требования

- Python 3.11
- Структура проекта должна быть сохранена (input, out, source)

### Запуск

```bash
git clone https://github.com/dima-dimka04/Python_AQA
cd Python_AQA
python main.py

